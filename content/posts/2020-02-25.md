---

title: Database 기초

date: "2020-02-25T20:37:32.169Z"

template: "post"

draft: false

slug: "blogdatabase(1)"

category: "Database"

description: "위코드 은우님이 발표하신 Database기초 강의 자료입니다"

tags:
  - "database"
  - "web"
  - "sql"

---



# Database 기초 이해 및 설치

- 데이터를 저장 및 보존 하는 시스템
- Application에서는 데이터가 메모리 상에서 존재한다. 그리고 메모리에 존재하는 데이터는 보존이 되지 않는다. 해당 애플리케이션이 종료하면 메모리에 있던 데이터들은 다시 읽어 들일 수 없다.
- 그럼으로 데이터를 장기 기간동안 저장 및 보존 하기 위해서 데이터 베이스를 사용하는 것이다.
- 일반적으로 database에는 크게 관계형 데이터베이스(RDBMS)와 "NoSQL"로 명칭되는 비관계형(Non-relational) database가 있다.

## 관계형 데이터베이스(RDBMS, Relational DataBase Management System)

- 이름 그대로, 관계형 데이터 모델에 기초를 둔 데이터베이스 시스템을 말한다.
- 관계형 데이터란 데이터를 서로 상호관련성을 가진 형태로 표현한 데이터를 말한다.
  - 모든 데이터들은 2차원 테이블(table)들로 표현 된다.
  - 각각의 테이블은 컬럼(column)과 row(로우)로 구성된다.
    - 컬럼은 테이블의 각 항목을 말한다. 행으로 생각하면 된다.
    - 로우는 각 항목들의 실제 값들을 이야기 한다. 열로 생각하면 된다.
    - 각 로우는 저만의 고유 키(Primary Key)가 있다. 주로 이 primary key를 통해서 해당 로우를 찾거나 인용(reference)하게 된다.
- 각각의 테이블들은 서로 상호관련성을 가지고 서로 연결될 수 있다.
  - 테이블끼리의 연결에는 크게 3가지 종류가 있다.
    - one to one
    - one to many
    - many to many
- 대표적인 관계형 데이터베이스에는 MySQL과 PostgreSQL(줄여서 Postgres)가 있다.

### One To One

- 테이블 A의 로우와 테이블 B의 로우가 정확히 일대일 매칭이 되는 관계를 one to one 관계라고 한다.

![Nulla faucibus](/media/onetoone.png)
*users and user_profiles - one to one*

### One To Many

- 테이블 A의 로우가 테이블 B의 여러 로우와 연결이 되는 관계를 one to many 관계라고 함.

![Nulla faucibus](/media/onetomany.png)

*각 고객은 여러 제품을 구매할 수 있지만 구매된 제품의 주인은 오직 한 고객 뿐이다 - one to many*

### Many To Many

- 테이블 A의 여러 로우가 테이블 B의 여러 로우와 연결이 되는 관계를 many to many 라고 함.

![Nulla faucibus](/media/manytomany.png)

*책은 여러 작가에 의해 쓰일 수 있고 작가들은 여러 책을 쓸 수 있다 - many to many*

### 어떻게 테이블과 테이블을 연결하는가?

- Foreign key(외부키)라는 개념을 사용하세 주로 연결
- 앞서 본 one to one 예에서 user_profiles 테이블의 user_id 컬럼은 users 테이블에 걸려있는 외부 키라고 지정한다.
- 즉 데이터베이스에게 user_id의 값은 users 테이블의 id 값이며 그러므로 users 테이블의 id 컬럼에 존재하는 값만 생성될 수 있다.
  - 만일 users 테이블에 없는 id 값이 user_id 에 지정되면 에러가 난다.

### 왜 테이블들을 연결하는가?

- 왜 정보를 여러 테이블에 나누어서 저장하는가?
- 앞서 본 one to many의 예에 경우 그냥 하나의 테이블에 고객 정보와 구입한 제품 정보 모두를 저장 하면 안되는가?
- 하나의 테이블에 모든 정보를 다 넣으면 동일한 정보들이 불필요하게 중복되어 저장된다.
  - 더 많은 디스크를 사용하게 되고
  - 또한, 잘못된 데이터가 저장 될 가능성이 높아진다.
    - 예를 들어, 고객의 아이디는 동일한데 이름이 틀린 로우들이 있다면 어떻게 해야 하는가? 어떤 이름이 정확한건가?
- 여러 테이블에 나누어서 저장한후 필요한 테이블 끼리 연결 시키면 위의 2문제가 사라진다.
  - 중복된 데이터를 저장하지 않음으로 디스크를 더 효율적으로 쓰고,
  - 또한 서로 같은 데이터이지만 부분적으로 틀린 데이터가 생기는 문제가 없어진다.
  - 이것을 `normalization`이라고 한다.

### ACID(Atomicity, Consistency, Isolation, Durability)

- 원자성, 일관성, 고립성, 지속성
- `원자성(Atomicity)`은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.
- `일관성(Consistency)`은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.
- `고립성(Isolation)`은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야 한다.
- `지속성(Durability)`은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

### 트랜잭션(Transaction)

- ACID를 제공함으로 따라서 트랜잭션(일련의 작업들을 한번에 하나의 unit으로 실행하는것) 기능을 제공하다.
  - 트랜잭션은 일련의 작업들이 마치 하나의 작업처럼 취급되어서 모두 다 성공하거나 아니면 모두 다 실패하는걸 이야기 한다.
  - Commit & rollback

## NoSQL 데이터베이스

- 비관계형 타입의 데이터를 저장할때 주로 사용되는 데이터베이스 시스템
- 관계형 데이터베이스와 다르게 비관계형 이기 때문에 데이터들을 저장하기 전에 정의 할 필요가 없다.
  - 관계형 데이터베이스는 데이터들을 저장하기 전에 어디에 어떻게 저장할것인지를 정의 해야한다.
    - 즉 테이블을 정의해야함 (테이블 이름, 테이블과 다른 테이블의 관계, 각 컬럼의 타입 등등)
- MongoDB, Redis, Cassandra 등이 가장 대표적인 NoSQL 데이터 베이스이다.

## SQL(RDBMS) VS NoSQL

### SQL

- 장점:
  - 관계형 데이터베이스는 데이터를 더 효율적으로 그리고 체계적으로 저장할 수 있고 관리 할 수 있다.
  - 미리 저장하는 데이터들의 구조(테이블 스키마)를 정의 함으로 데이터의 완전성이 보장된다.
  - 트랜잭션(transaction)
- 단점:
  - 테이블을 미리 정의해야 함으로 테이블 구조 변화 등에 덜 유연한다.
  - 확장성이 쉽지 않다.
    - 역시 테이블 구조가 미리 정의 되어 있다보니 단순히 서버를 늘리는것 만으로 확장하기가 쉽지 않고 서버의 성능 자체도 높여야 한다.
    - 서버를 늘려서 분산 저장 하는것도 쉽지 않다.
    - Scale up (서버의 성능을 높이는것)으로 확장성이 됨.
- 정형화된 데이터들 그리고 데이터의 완전성이 중요한 데이터들을 저장하는데 유리하다.
  - 예) 전자상거래 정보. 은행 계좌 정보, 거래 정보 등등.

### NoSQL

- 장점:
  - 테이터 구조를 미리 정의하지 않아도 됨으로 저장하는 데이터의 구조 변화에 유연하다.
  - 확장하기가 비교적 쉽다. 그냥 서버 수를 늘리면 됨(scale out)
  - 확장하기가 쉽고 테이터의 구조도 유연하다 보니 방대한 양의 데이터를 저장하는데 유리하다.
- 단점:
  - 데이터의 완전성이 덜 보장된다.
  - 트랜잭션이 안되거나 비교적 불안정하다.
- 주로 비정형화 데이터 그리고 완전성이 상대적으로 덜 유리한 데이터를 저장하는데 유리하다.
  - 예) 로그 데이타