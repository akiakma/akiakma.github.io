{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/divingintoreact","result":{"data":{"markdownRemark":{"id":"c028893b-383b-5827-8451-fbd236808f32","html":"<h1 id=\"i-wish-i-knew-these-before-diving-into-react\" style=\"position:relative;\"><a href=\"#i-wish-i-knew-these-before-diving-into-react\" aria-label=\"i wish i knew these before diving into react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>I wish I knew these before diving into React</h1>\n<p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em>\n<em>원본 링크 : <a href=\"https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>\n<h3 id=\"table-of-contents\" style=\"position:relative;\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of contents</h3>\n<ul>\n<li>By default, setState triggers a re-render</li>\n<li>setState updates the local state asynchronously</li>\n<li>Component Lifecycle is important!</li>\n<li>Use componentWillReceiveProps</li>\n<li>Use React Developer Tools</li>\n<li>Use CRA(Create React App)</li>\n</ul>\n<h2 id=\"1-by-default-setstate-triggers-a-re-render\" style=\"position:relative;\"><a href=\"#1-by-default-setstate-triggers-a-re-render\" aria-label=\"1 by default setstate triggers a re render permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. By default, setState triggers a re-render</h2>\n<blockquote>\n<p>기본적으로 <code class=\"language-text\">setState</code> 메소드는 해당 컴포넌트의 재렌더링(re-render)을 발생시킨다.</p>\n</blockquote>\n<p>리액트의 기본 동작은 애플리케이션을 구성하고 있는 컴포넌트에서 발생하는 모든 변경사항에 대해서 다시 렌더링 하는 것이고 대부분의 경우 이 이러한 기본 동작에 맡겨도 정상적으로 동작합니다. 하지만 불필요한 re-render는 컴포넌트의 라이프 사이클 압장에서 봤을 때, Best practice일 수 없습니다.</p>\n<p>각각의 컴포넌트들은 <code class=\"language-text\">shouldComponentUpdate</code>라는 메소드를 가지고 있고 이것은 <code class=\"language-text\">state</code>가 변경되거나 부모 컴포넌트로부터 새로운 <code class=\"language-text\">props</code>를 전달받을 때 실행됩니다. React는 이 메소드(<code class=\"language-text\">shouldComponentUpdate</code>)의 반환 값에 따라서 re-render를 할지에 대한 여부를 결정하게 됩니다.</p>\n<p>기본적으로 <code class=\"language-text\">shouldComponentUpdate</code> 메소드는 <code class=\"language-text\">true</code>를 반환합니다. 하지만 React 개발자는 re-render를 원하지 않는 경우에, 이 return value를 <code class=\"language-text\">false</code>로 오버라이드 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">shouldComponentUpdate(nextProps, nextState) {\n    const vitalPropsChange = this.props.bar !== nextProps.bar;\n    const vitalStateChange = this.state.foo !== nextState.foo;    \n    return vitalPropsChange || vitalStateChange;\n}\n// React will not re-render the component unless vitalPropsChange\n// or vitalStateChange is true.</code></pre></div>\n<h3 id=\"important-notes\" style=\"position:relative;\"><a href=\"#important-notes\" aria-label=\"important notes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>important notes:</h3>\n<ol>\n<li><code class=\"language-text\">shouldComponentUpdate</code>를 잘못 설정하거나 이러한 설정을 잊어 버리면 구성 요소가 예상대로 업데이트되지 않아 애플리케이션에 문제가 발생할 수 있습니다.</li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">shouldComponentUpdate</code></pre></div>\n<p>에서 계산을 실행하는 것은 성능과 노력면에서 비용이 많이들 수 있으므로 그만한 가치가 있는지 확인해야합니다.</p>\n<p>React ‘s Performance Tools</p>\n<p>를 사용하여</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">shouldComponentUpdate</code></pre></div>\n<p>사용 전후에 낭비되는 사이클 수를 확인하는 것이 좋습니다. 아주 간단한 사용법이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Perf.start() \n// React operations in-between are recorded for analyses.\nPerf.stop()\nPerf.printWasted()</code></pre></div>\n</li>\n</ol>\n<h2 id=\"2-setstate-updates-the-local-state-asynchronously\" style=\"position:relative;\"><a href=\"#2-setstate-updates-the-local-state-asynchronously\" aria-label=\"2 setstate updates the local state asynchronously permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. setState updates the local state asynchronously</h2>\n<blockquote>\n<p><code class=\"language-text\">setState</code> 메소드는 <strong>비동기</strong>로 state를 업데이트 한다.</p>\n</blockquote>\n<p><code class=\"language-text\">setState</code>메소드는 즉시 실행되는, 동기적으로 실행되는 것이 아니라 하나의 <strong>요청</strong>이라고 생각해야 합니다. 즉, <code class=\"language-text\">setState</code>를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아닙니다.</p>\n<p><code class=\"language-text\">setState</code>를 호출한 직후에 <code class=\"language-text\">this.state</code>에 접근하는 것은 흔한 실수 입니다. 일반적으로, <code class=\"language-text\">setState</code> 메소드 내에서 <code class=\"language-text\">this.state</code>를 사용하는 것은 신뢰할 수 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// this.state.value is initially 0\nthis.setState({value: this.state.value + 1});\nthis.setState({value: this.state.value + 1});\nthis.setState({value: this.state.value + 1});\n// this.state.value is 1 instead of 3</code></pre></div>\n<p>만약 이전의 상태에 기반하여 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 <code class=\"language-text\">updater</code> 함수를 사용하는 것입니다. <code class=\"language-text\">updater</code>함수를 <code class=\"language-text\">setState</code> 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있습니다. ( <code class=\"language-text\">setState(updater, [callback])</code> ) 예제 코드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.setState((prevState) =&gt; ({value: prevState.value + 1}));</code></pre></div>\n<p>여기서 <code class=\"language-text\">[callback]</code>은 optional argument로 <code class=\"language-text\">setState</code>의 실행이 완료된 후 실행되며 해당 <code class=\"language-text\">callback</code>이 실행된 후에 해당 컴포넌트의 re-render가 이루어집니다. <code class=\"language-text\">updater</code>에 대한 보다 자세한 내용은 다음 <a href=\"https://reactjs.org/docs/react-component.html#setstate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">링크</a>를 참고하세요.</p>\n<h2 id=\"3-component-lifecycle-is-important\" style=\"position:relative;\"><a href=\"#3-component-lifecycle-is-important\" aria-label=\"3 component lifecycle is important permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Component Lifecycle is important!</h2>\n<blockquote>\n<p>컴포넌트의 라이프 사이클이 중요하다!</p>\n</blockquote>\n<p>React를 이해하는데 있어서 가장 첫번째로 이해해야 하는 부분이 바로 <strong>Component life cycle</strong>입니다. 각각의 React 컴포넌트는 component의 life cycle 안에서 특정 시간에 호출할 수 있는 메소드들을 내장하고 있습니다. 이 컴포넌트 내장 메소드들을 올바르게 사용하기 위해서는 해당 메소드들이 실행되는 순서를 이해해야만 합니다. 이 라이프 사이클을 세 부분으로 나눌 수 있습니다.</p>\n<h3 id=\"mounting\" style=\"position:relative;\"><a href=\"#mounting\" aria-label=\"mounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting</h3>\n<p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p>\n<ol>\n<li>constructor</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ol>\n<h3 id=\"updating\" style=\"position:relative;\"><a href=\"#updating\" aria-label=\"updating permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Updating</h3>\n<p><code class=\"language-text\">prop</code> 또는 <code class=\"language-text\">state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p>\n<h4 id=\"props-change\" style=\"position:relative;\"><a href=\"#props-change\" aria-label=\"props change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Props Change</h4>\n<ol>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h4 id=\"state-change\" style=\"position:relative;\"><a href=\"#state-change\" aria-label=\"state change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>State Change</h4>\n<ol>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"unmounting\" style=\"position:relative;\"><a href=\"#unmounting\" aria-label=\"unmounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmounting</h3>\n<ul>\n<li>componentWillUnmount</li>\n</ul>\n<h3 id=\"life-cycle과-관련된-좋은-article\" style=\"position:relative;\"><a href=\"#life-cycle%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%A2%8B%EC%9D%80-article\" aria-label=\"life cycle과 관련된 좋은 article permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life Cycle과 관련된 좋은 Article</h3>\n<ul>\n<li>\n<p>React Lifecycle Methods - how and when to use them</p>\n<ul>\n<li><a href=\"https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">번역 링크</a></li>\n<li><a href=\"https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">원본 링크</a></li>\n</ul>\n</li>\n<li><a href=\"https://reactjs.org/docs/react-component.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Official Document</a></li>\n</ul>\n<h2 id=\"4-use-componentwillreceiveprops\" style=\"position:relative;\"><a href=\"#4-use-componentwillreceiveprops\" aria-label=\"4 use componentwillreceiveprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Use componentWillReceiveProps</h2>\n<blockquote>\n<p><code class=\"language-text\">componentWillReceiveProps</code> 메소드를 사용해라.</p>\n</blockquote>\n<p>만약 <code class=\"language-text\">props</code>의 변경에 따라서 상태를 변경해야 한다면, 이 <code class=\"language-text\">componentWillReceiveProps</code> 메소드가 필요합니다. <code class=\"language-text\">this.props</code>와 <code class=\"language-text\">nextProps</code>를 비교해서 중요한 변화(significant change)가 있다면 해당 메소드를 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentWillReceiveProps(nextProps) {\n  if (this.props.foo !== nextProps.foo) {\n    this.whenFooChanges();\n  }\n  if (this.porps.bar !== nextProps.bar) {\n    this.whenBarChanges();\n  }\n}</code></pre></div>\n<h3 id=\"two-important-notes\" style=\"position:relative;\"><a href=\"#two-important-notes\" aria-label=\"two important notes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Two important notes:</h3>\n<ol>\n<li><code class=\"language-text\">props</code>가 변경되지 않아도 <code class=\"language-text\">componentWillReceiveProps</code>는 실행하기 때문에 <code class=\"language-text\">this.props</code>와 <code class=\"language-text\">nextProps</code>를 비교하는 것이 중요합니다.</li>\n<li><code class=\"language-text\">componentWillReceiveProps</code>은 해당 컴포넌트가 <strong>mounted</strong> 되기 전에 실행되어 새로운 <code class=\"language-text\">props</code>를 받습니다. 이것은 React가 mount 중에는 초기 props에 대해 <code class=\"language-text\">componentWillReceiveProps</code>를 호출하지 않는다는 것을 의미합니다.</li>\n</ol>\n<h3 id=\"추가-내용\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80-%EB%82%B4%EC%9A%A9\" aria-label=\"추가 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가 내용</h3>\n<p>React version 16에서 <code class=\"language-text\">componentWillReceiveProps</code>를 사용하여 상태를 변경할 때는 <strong>동기적으로</strong> 업데이트 해야 합니다.(dispatch request 또는 <code class=\"language-text\">setTimeout</code>과 같은 비동기적 요청은 해당 메소드에서 처리하면 안 됩니다.)\n<strong>React Fiber</strong> 를 사용하면 라이프 사이클이 진행되기 전에 <code class=\"language-text\">componentWill[*]</code> 메서드가 여러 번 호출 될 수 있습니다. <code class=\"language-text\">props</code>이 변경될 때 상태를 비동기적으로 업데이트하려면 <code class=\"language-text\">componentDidUpdate</code>를 사용해야 합니다.</p>\n<h2 id=\"5-use-react-developer-tools\" style=\"position:relative;\"><a href=\"#5-use-react-developer-tools\" aria-label=\"5 use react developer tools permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Use React Developer Tools</h2>\n<blockquote>\n<p>각종 React 개발자 도구를 사용해라.</p>\n</blockquote>\n<p>React Developer Tools를 사용하면 애플리케이션을 구성하고 있는 React 컴포넌트의 계층, 컴포넌트의 <code class=\"language-text\">props</code> 및 <code class=\"language-text\">state</code>를 검사 할 수 있습니다. React는 모두 컴포넌트에 관한 것이기 때문에 많은 경우, 매우 유용합니다. 브라우저 확장 프로그램 (<a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chrome용</a> 및 <a href=\"https://addons.mozilla.org/ko/firefox/addon/react-devtools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Firefox 용</a>)과 <a href=\"https://github.com/facebook/react-devtools/tree/master/packages/react-devtools\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">독립 실행 형 앱</a>으로 존재합니다.</p>\n<h2 id=\"6-use-cracreate-react-app\" style=\"position:relative;\"><a href=\"#6-use-cracreate-react-app\" aria-label=\"6 use cracreate react app permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Use CRA(Create React App)</h2>\n<blockquote>\n<p>CRA를 사용해라.</p>\n</blockquote>\n<p>Facebook의 <a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Create React App</a>을 사용하면 빌드 구성없이 React 앱을 만들 수 있습니다. CRA는 사용하기가 매우 쉽고 잘 갖춰진 documentation을 가지고 있습니다. Node> = 6 만 있으면 되며 macOS, Windows 및 Linux에서 작동합니다. 개발 생산성을 높여주는 HRM도 해당 scaffolding 모듈에서 지원하고 있습니다. (개인적으로는 글로벌로 설치해도 아쉽지 않은 녀석입니다!)</p>\n<h3 id=\"역자-덧붙임\" style=\"position:relative;\"><a href=\"#%EC%97%AD%EC%9E%90-%EB%8D%A7%EB%B6%99%EC%9E%84\" aria-label=\"역자 덧붙임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역자 덧붙임</h3>\n<p>좋은 참고자료를 첨부합니다.</p>\n<ul>\n<li><a href=\"https://github.com/reactkr/learn-react-in-korean\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">한국어로 배우는 리액트</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript-React-Starter\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript-React-Stater</a></li>\n<li><a href=\"https://github.com/chantastic/reactpatterns.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-patterns (영어)</a></li>\n</ul>","fields":{"slug":"/posts/divingintoreact","tagSlugs":["/tag/react/"]},"frontmatter":{"date":"2020-03-20T19:10:20.169Z","description":"I wish I knew these before diving into React.","tags":["react"],"title":"React할때 알면 좋은것들","socialImage":null}}},"pageContext":{"slug":"/posts/divingintoreact"}}}