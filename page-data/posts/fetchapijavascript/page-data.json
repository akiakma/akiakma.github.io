{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/fetchapijavascript","result":{"data":{"markdownRemark":{"id":"b673e4d0-60d9-577b-b699-ace9acd64ccb","html":"<h1 id=\"javascript-fetch-api\" style=\"position:relative;\"><a href=\"#javascript-fetch-api\" aria-label=\"javascript fetch api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Javascript Fetch API</h1>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>그 동안 WEB에서 어떤 리소스를 비동기로 요청하기 위해서는 XHR(XML HTTP Request)객체를 사용했어야 했었는데,</p>\n<p>XHR은 잘 디자인되어 있는 API가 아니다. 요청의 상태나 변경을 구독하려면 Event를 등록해서 변경사항을 받아야 했고</p>\n<p>요청의 성공, 실패 여부나 상태에 따라 처리하는 로직이 들어가기 좋지 않았다.</p>\n<p>이를 보완하기 위해서 Fetch API를 도입하였는데 이는 HTTP 요청에 최적화 되어 있고 상태도 잘 추상화 되어 있고</p>\n<p>Promise를 기반으로 되어 있기때문에 상태에 따른 로직을 추가하고 처리하는데에 최적화 되어 있다.</p>\n<h1 id=\"baisc-use\" style=\"position:relative;\"><a href=\"#baisc-use\" aria-label=\"baisc use permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Baisc Use</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fetch(&#39;http://hanur.me/users&#39;)\n.then(res =&gt; res.json())\n.then(data =&gt; data.filter(item =&gt; item.isRequired));</code></pre></div>\n<p>기본적으로 위와 같이 사용할 수 있다.</p>\n<h1 id=\"basic\" style=\"position:relative;\"><a href=\"#basic\" aria-label=\"basic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Basic</h1>\n<p>Fetch API는 3개의 Interface를 도입하고 있는데 Headers, Request, Response 이다.</p>\n<p>이는 곧 HTTP의 개념과 대응되는 Interface이다.</p>\n<h1 id=\"headers\" style=\"position:relative;\"><a href=\"#headers\" aria-label=\"headers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Headers</h1>\n<p>Headers 객체는 HTTP Header와 대응되는 객체이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers();\nconst content = &quot;HI&quot;;\nreqHeader.append(&quot;Content-Type&quot;, &quot;application/json&quot;);\nreqHeader.append(&quot;Content-Length&quot;, content.length.toString());</code></pre></div>\n<p>위 처럼 Headers 객체를 만들고 append Method를 이용하여 HTTP Request Header 정보를 추가할 수 있다.</p>\n<p>혹은 Append가 아닌 생성자로 Object literal를 이용하여 정의할 수 도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const content = &quot;HI&quot;;\nconst reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Length&quot;: content.length.toString(), \n});</code></pre></div>\n<p>더 자세히 보기위해서 Headers 객체의 Prototype을 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">append: function append()\ndelete: function delete()\nentries: function entries()\nforEach: function forEach()\nget: function get()\ngetAll: function getAll()\nhas: function has()\nkeys: function keys()\nset: function set()\nvalues: function values()\nconstructor: function Headers()\nSymbol(Symbol.iterator): function ()\nSymbol(Symbol.toStringTag): &quot;Headers&quot;</code></pre></div>\n<p>가장 눈에 띄는것은 Symbol.iterator를 구현한 Iterable 객체라는 점이다.</p>\n<p>아마 기본적으로 key, value로 Header를 Set하고 있으니 해당 아이템을 List로 Iterator를 돌릴 수 있게 제공하는것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Length&quot;: &quot;30&quot;,\n});for(const item of reqHeader){\n  console.log(item)\n}// console\n// -&gt; [&quot;content-type&quot;, &quot;application/json&quot;]\n// -&gt; [&quot;content-length&quot;, &quot;30&quot;]</code></pre></div>\n<p>for of문은 Symbol.iterator를 구현하고 있기때문에 for of문은 정상적으로 동작하고 item은 내 예상과 다르게 Array에 Key, Valuer가 담긴 모습으로 뽑히고 있다.</p>\n<p>내가 예상해던건 Object에 {key: value} 느낌이였는데 아마 Object로 하면 해당 Key만 뽑는게 쉽지 않아서 Array에 담은것 같다. (Object.keys나 Object.values를 이용하면 되긴하지만 일을 2번하는 느낌이므로…)</p>\n<h2 id=\"entries\" style=\"position:relative;\"><a href=\"#entries\" aria-label=\"entries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>entries()</h2>\n<p>해당 메서드는 Iterator를 리턴해주는데 <code class=\"language-text\">Headers[Symbol.iterator]()</code>와 같은 결과를 반환한다.</p>\n<h2 id=\"foreach\" style=\"position:relative;\"><a href=\"#foreach\" aria-label=\"foreach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>forEach()</h2>\n<p>forEach을 따로 제공해주는데 Iterator를 돌리는것과 또 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Length&quot;: &quot;30&quot;,\n});reqHeader.forEach((value, key, header) =&gt; console.log(value, key, header));</code></pre></div>\n<p>callback 함수의 파라미터로 value, key, header 순으로 들어오게 된다. header는 헌재 forEach를 돌고있는 해당 header 객체이다</p>\n<h2 id=\"keys\" style=\"position:relative;\"><a href=\"#keys\" aria-label=\"keys permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>keys()</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Length&quot;: &quot;30&quot;,\n});const keys = reqHeader.keys();for(const key of keys) {\n  console.log(key)\n}</code></pre></div>\n<p>keys()는 Header에 등록된 Request Header key를 반환하는 Iterator를 반환하는 메서드이다. 만약 중복된 키로 여러 개의 Value가 등록된 경우 중복된 여러개의 Key가 아닌 하나의 key만 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Type&quot;: &quot;plain/text&quot;,\n  &quot;Content-Length&quot;: &quot;30&quot;,\n});const keys = reqHeader.keys();for(const key of keys) {\n  console.log(key)\n}// console\n// -&gt; &quot;content-type&quot;\n// -&gt; &quot;content-length&quot;</code></pre></div>\n<h2 id=\"values\" style=\"position:relative;\"><a href=\"#values\" aria-label=\"values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>values()</h2>\n<p>values()는 Header에 등록된 Request Header value를 반환하는 Iterator를 반환하는 메서드이다.</p>\n<p>만약 중복된 key로 여러 value를 등록했을 경우 하나의 String에 ,Seperator로 이어서 반환된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers({\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;Content-Type&quot;: &quot;plain/text&quot;,\n  &quot;Content-Length&quot;: &quot;30&quot;,\n});const values = reqHeader.values();\nfor(const value of values) {\n  console.log(value)\n}// console\n// -&gt; &quot;application/json,plain/text&quot;\n// -&gt; &quot;30&quot;</code></pre></div>\n<p>먼저 등록된 value가 앞에 나오고 나중에 등록된 value가 뒤에 나오게 된다.</p>\n<h2 id=\"set과-append의-차이점\" style=\"position:relative;\"><a href=\"#set%EA%B3%BC-append%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"set과 append의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>set()과 append()의 차이점</h2>\n<p>set()과 append()가 겉으로 보기에는 비슷해보일 수 있다.</p>\n<p>두개의 API가 기본적인 사용법은 같은데 무슨 차이가 있나 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const reqHeader = new Headers();\nreqHeader.append(&quot;Content-Type&quot;, &quot;application/json&quot;);\nreqHeader.append(&quot;Content-Type&quot;, &quot;hihi&quot;);\nreqHeader.append(&quot;Content-Length&quot;, &quot;30&quot;);for(const value of reqHeader.values()){\n  console.log(value);\n}// console\n// -&gt; &quot;application/json,hihi&quot;\n// -&gt; &quot;30&quot;reqHeader.set(&#39;Content-Type&#39;, &#39;good&#39;);\nfor(const value of reqHeader.values()){\n  console.log(value);\n}\n// console\n// -&gt; &quot;good&quot;\n// -&gt; &quot;30&quot;</code></pre></div>\n<p>위 Code를 보면 알 수 있는 것처럼 append()는 설정을 추가해주는 메서드이고 set()은 해당 key를 이용해서 set해주고</p>\n<p>만약 같은 key가 있다면 덮어써주는 메서드이다.</p>\n<h2 id=\"guard\" style=\"position:relative;\"><a href=\"#guard\" aria-label=\"guard permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>guard</h2>\n<p>Headers 객체는 우리가 Request를 보낼때도 사용하고 Response로 받는 경우에도 사용하게 됩니다.</p>\n<p>우리가 직접 만든 Headers는 수정이 가능하지만, 만약 Response로 받은 Header의 경우 우리가 임의로 수정 할 수 없는게 맞습니다.</p>\n<p>Server에서 내려준 Response에 대한 Header 이기때문에 그대로 사용하는게 맞습니다. 그러므로 Header에는 Header를 수정할 수 있는지</p>\n<p>여부를 판단하는 guard가 존재합니다. guard는 Headers instance에 노출되어 있지 않아서 실제로 guard 값을 조회할 방법은 없습니다.</p>\n<p>하지만 내부적으로 존재하는 값입니다.</p>\n<ul>\n<li>none: 기본값.</li>\n<li>request: Request에 존재하는 Headers 객체를 위한 값.</li>\n<li>request-no-cors: no-cors mode로 생성된 Request의 Headers 객체를 위한 값.</li>\n<li>response: Response 객체에 있는 Headers 객체를 위한 값.</li>\n<li>immutable: ServiceWork를 위해서 사용되는 값. Header가 Read-only라는 것을 나타낸다.</li>\n</ul>\n<p>가장 기본값은 “none”이다. 이는 모든 변경을 사실상 허용한다는 의미이다.</p>\n<p>“request”는 request를 위한 Header name이 아닌 경우 변경을 금지한다.</p>\n<p>예를 들어서 request의 Headers의 guard 속성은 “request”이다.</p>\n<p>그래서 Request Header에 정의되는 속성이 아닌 Response Header 값을 세팅한다거나 하면 Type Error를 발생시킨다.</p>\n<p>이런 방식으로 guard가 작동하는데 확인할 수 없다는 점이 아쉬운 점이다.</p>\n<h1 id=\"request\" style=\"position:relative;\"><a href=\"#request\" aria-label=\"request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Request</h1>\n<p>Request는 HTTP 요청을 통해 자원을 가져오는 인터페이스이다.</p>\n<p>Request는 URL, Header, body가 필요하다. 그리고 Request에 대한 mode 제한과 certificate 관련 설정도 추가할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const req = new Request(&quot;/api/posts&quot;, {\n  method: &quot;GET&quot;,\n  headers: new Headers({\n    &quot;content-type&quot;: &quot;application/json&quot;,\n  }),\n  body: {\n    name: &quot;LeeHanur&quot;,\n  }\n});</code></pre></div>\n<p>이런 느낌으로 사용할 수 있다. 물론 Request 객체를 생성한다고 HTTP Request가 날아가는건 아니다. Request 객체는 어떠한 HTTP Request에 대한 스팩을 정의한 것이고 실제로 Fetching 하는건 fetch Method를 이용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const req = new Request(&quot;/api/posts&quot;, {\n  method: &quot;GET&quot;,\n  headers: new Headers({\n    &quot;content-type&quot;: &quot;application/json&quot;,\n  }),\n  body: {\n    name: &quot;LeeHanur&quot;,\n  }\n});\n// is not Fetchedfetch(req).then(res =&gt; res.json()).then(data =&gt; console.log(data));\n// is fetched Data!</code></pre></div>\n<p>이런 느낌이라고 생각하면 된다.</p>\n<p>Request 객체의 첫번째 인자는 호출한 Path가 들어가고, 두번째 인자에는 Request에 대한 정보가 들어가는데,</p>\n<ul>\n<li>method</li>\n<li>headers</li>\n<li>body</li>\n<li>mode</li>\n<li>cache</li>\n<li>credentials</li>\n<li>redirect</li>\n<li>referrer</li>\n<li>integrity</li>\n</ul>\n<h2 id=\"method\" style=\"position:relative;\"><a href=\"#method\" aria-label=\"method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>method</h2>\n<p>method는 HTTP Method와 동일한 스팩으로 들어가면 된다. GET / POST / HEAD / PUT / DELETE / OPTION / PATCH 등등..</p>\n<p>만약 지정을 안할 경우 기본값은 “GET”이 된다. 그리고 소문자로 지정해도 자동으로 대문자로 Uppercase된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const req = new Request(&#39;/api/posts&#39;, {\n  method: &#39;get&#39;\n});req.method // &quot;GET&quot;</code></pre></div>\n<h2 id=\"headers-1\" style=\"position:relative;\"><a href=\"#headers-1\" aria-label=\"headers 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>headers</h2>\n<p>headers는 Request Header를 지정해주는 곳인데 2가지 형식으로 넣을 수 있다. Object literal과 Headers 객체의 인스턴스를 넣을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const req = new Request(&#39;/api/posts&#39;, {\n  method: &quot;GET&quot;,\n  headers: {\n    &#39;content-type&#39;: &#39;application/json&#39;,\n  }\n});const req2 = new Request(&#39;/api/posts&#39;, {\n  method: &#39;GET&#39;,\n  headers: new Headers({\n   &#39;content-type&#39;: &#39;application/json&#39;,\n  })\n})</code></pre></div>\n<h2 id=\"body\" style=\"position:relative;\"><a href=\"#body\" aria-label=\"body permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>body</h2>\n<p>body는 HTTP Request에 실을 데이터인데 여러가지 타입을 넣을 수 있다. 스팩을 보면 아래와 같이 명시되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">typedef (Blob or BufferSource or FormData or URLSearchParams or ReadableStream or USVString)</code></pre></div>\n<p>Blob도 보낼 수 있는 부분을 보면 파일전송까지 모두 고려한것으로 볼 수 있고, FormData와 URLSearchParams도 넣을 수 있도록 모두 고려되어 있다.</p>\n<h2 id=\"mode\" style=\"position:relative;\"><a href=\"#mode\" aria-label=\"mode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mode</h2>\n<p>mode는 Request시 어떤 Origin에 있는 Resource에 접근할지를 미리 설정할 수 있는 부분이다.</p>\n<ul>\n<li>same-origin</li>\n<li>no-cors(Default)</li>\n<li>cors</li>\n</ul>\n<p>same-origin은 현재 Origin과 같은 Origin에만 요청 할 수 있는 설정이다. 이를 이용하면 해당 Request는 같은 Origin에만 동작한다는걸 보장할 수 있다.</p>\n<p>no-cors는 기본설정으로, 일반적으로 CDN에 있는 데이터를 가져온다거나 이미지를 불러온다거나 하는 기본적인 동작들을 할 수 있다. GET, POST, HEAD 이외에 다른 Method는 지원하지 않는다.</p>\n<p>cors는 여러 다른 API에 접근할때 사용할 mode이다. Response Header가 일부 공개되지 않을 수 있지만 Body는 모두 접근가능하도록 Response가 온다.</p>\n<h1 id=\"response\" style=\"position:relative;\"><a href=\"#response\" aria-label=\"response permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Response</h1>\n<p>Response는 fetch를 호출하면 가져올 수 있는 객체인데, Response의 경우는 ServiceWorker가 아니면 생성해서 쓰는것이 크게 의미가 없다.</p>\n<ul>\n<li>status</li>\n<li>statusText</li>\n<li>ok</li>\n<li>headers</li>\n<li>type</li>\n</ul>\n<h2 id=\"status\" style=\"position:relative;\"><a href=\"#status\" aria-label=\"status permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>status</h2>\n<p>status는 HTTP Response Code를 담고 있다. 일반적으로 성공적이였다면 200이 떨어지게 될것이다.</p>\n<h2 id=\"statustext\" style=\"position:relative;\"><a href=\"#statustext\" aria-label=\"statustext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>statusText</h2>\n<p>statusText는 기본값은 “ok”이고 상황에 따라 다른 Message가 담길 수 있다.</p>\n<h2 id=\"ok\" style=\"position:relative;\"><a href=\"#ok\" aria-label=\"ok permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ok</h2>\n<p>ok는 Status의 200299의 값을 추상화한 boolean인데 200299사이의 status이면 true를 가지게 된다.</p>\n<h2 id=\"headers-2\" style=\"position:relative;\"><a href=\"#headers-2\" aria-label=\"headers 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>headers</h2>\n<p>Response Headers 이기때문에 headers의 guard 속성은 response로 되어있다.</p>\n<h2 id=\"type\" style=\"position:relative;\"><a href=\"#type\" aria-label=\"type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>type</h2>\n<p>type은 Response 객체의 type을 말한다.</p>\n<ul>\n<li>basic</li>\n<li>cors</li>\n<li>error</li>\n<li>opaque</li>\n</ul>\n<p>basic은 가장 기본적인 속성이고 error가 난 Response가 아니고, Request시 mode의 값이 cors가 아니라면 basic이 오게 될 것이다. 가능한 모든 Headers 속성에 접근할 수 있다.</p>\n<p>cors는 Request의 mode가 cors일때 나오는 값인데, 이 때는 Headers의 일부 값에 대한 접근이 제한된다.</p>\n<p>error는 Response.error()를 호출했을때 나오는 type이다.</p>\n<p>opaque는 Request mode를 no-cors로 설정했을때 가지게 되는 type이다.</p>\n<h1 id=\"body를-다루기\" style=\"position:relative;\"><a href=\"#body%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EA%B8%B0\" aria-label=\"body를 다루기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Body를 다루기</h1>\n<p>Request와 Response 모두 Body값이 존재하는데 Body는 아래와 같은 종류로 설정할 수 있다.</p>\n<ul>\n<li>ArrayBuffer</li>\n<li>ArrayBufferView (Uint8Array와 친구들)</li>\n<li>Blob/File</li>\n<li>string</li>\n<li>URLSearchParams</li>\n<li>FormData</li>\n</ul>\n<p>이런 다양한 종류의 Body를 다루기위해서 제공되는 Method가 있다.</p>\n<ul>\n<li>arrayBuffer()</li>\n<li>blob()</li>\n<li>json()</li>\n<li>text()</li>\n<li>formData()</li>\n</ul>","fields":{"slug":"/posts/fetchapijavascript","tagSlugs":["/tag/javascript/","/tag/fetch-api/"]},"frontmatter":{"date":"2020-04-01T19:10:20.169Z","description":" fetch API 관한 글입니다.","tags":["javascript","FetchAPI"],"title":"React Binding","socialImage":null}}},"pageContext":{"slug":"/posts/fetchapijavascript"}}}